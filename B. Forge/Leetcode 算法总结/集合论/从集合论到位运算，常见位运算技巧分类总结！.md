## 前言

本文将扫清位运算的迷雾，在集合论与位运算之间建立一座桥梁。

在高中，我们学了集合论（set theory）的相关知识。例如，包含若干整数的集合 S={0,2,3}。在编程中，通常用哈希表（hash table）实现集合。例如 Java 中的 `HashSet`，C++ STL 中的 `unordered_set`。

在集合论中，有交集 ∩、并集 ∪、包含于 ⊆ 等等概念。如果编程实现「求两个哈希表的交集」，需要一个个地遍历哈希表中的元素。有没有效率更高的做法呢？

该二进制上场了。

集合可以用二进制表示，二进制**从低到高**第 i 位为 1 表示 i 在集合中，为 0 表示 i 不在集合中。例如集合 {0,2,3} 可以用二进制数 1101 表示；反过来，二进制数 1101 就对应着集合 {0,2,3}。

正式地说，包含非负整数的集合 S 可以用如下方式「压缩」成一个数字：
$$f(S)=\sum_{s \in S}2^{i}$$
上面举例的 {0,2,3} 就可以压缩成2<sup>0</sup>+2<sup>2</sup>+2<sup>3</sup>=13，也就是二进制数 1101。

利用位运算「并行计算」的特点，我们可以高效地做一些和集合有关的运算。按照常见的应用场景，可以分为以下四类：

1. 集合与集合
2. 集合与元素
3. 遍历集合
4. 枚举集合

## 一、集合与集合

其中 & 表示按位与，∣ 表示按位或，⊕ 表示按位异或，∼ 表示按位取反。

其中「对称差」指仅在其中一个集合的元素。

| 术语       | 集合        | 位运算  | 举例                         | 举例                 |
| ---------- | ----------- | ------- | ---------------------------- | -------------------- |
| 交集       | A ∩ B       | a & b   | {0,2,3} ∩ {0,1,2}={0,2}​     | 1101 & 0111 = 0101​  |
| 并集       | A ∪ B       | a \|  b | {0,2,3}∪{0,1,2} = {0,1,2,3}​ | 1101 \| 0111 = 1111​ |
| 对称差     | A Δ B       | a⊕b     | ​{0,2,3} Δ {0,1,2} = {1,3}​  | 1101 ⊕ 0111 = 1010​  |
| 差         | A∖B         | a&∼b    | ​{0,2,3} \\ {1,2} = {0,3}    | 1101 & 1001 = 1001​  |
| 差（子集） | A\\B（B⊆A） | a⊕b     | {0,2,3} \\ {0,2} = {3}​      | 1101⊕0101=1000​      |
| 包含于  | A⊆B  |  a & b = a  a\|b =b |  {0,2}⊆{0,2,3} |   0101&1101=0101 0101\|1101=1101 | 

> 注 1：按位取反的例子中，仅列出最低 44 个比特位取反后的结果，即 01100110 取反后是 10011001。
> 注 2：包含于的两种位运算写法是等价的，在编程时只需判断其中任意一种。
> 注 3：编程时，请注意运算符的优先级。例如\=\=在某些语言中优先级更高。
## 二、集合与元素

通常会用到位移运算。

其中 <<<< 表示左移，>>>> 表示右移。
>注：左移 i 位相当于乘 2<sup>i</sup>，右移 i 位相当于除 2<sup>i</sup>。
![[Pasted image 20230802151750.png]]
![[Pasted image 20230802152046.png]]
某些数字可以借助标准库提供的函数算出:

![[Pasted image 20230616114225.png]]

特别地，只包含最小元素的子集，即二进制最低 1 及其后面的 0，也叫 lowbit，可以用 `s & -s` 算出。举例说明：

```
     s = 101100
    ~s = 010011
(~s)+1 = 010100 // 根据补码的定义，这就是 -s   最低 1 左侧取反，右侧不变
s & -s = 000100 // lowbit
```

## 三、遍历集合

设元素范围从 0 到 n−1，挨个判断元素是否在集合 s 中：

```c++
for (int i = 0; i < n; i++) {
    if ((s >> i) & 1) { // i 在 s 中
        // 处理 i 的逻辑
    }
}
```

## 四、枚举集合

设元素范围从 0 到 n−1，从空集枚举到全集：
```c++
for (int s = 0; s < (1 << n); s++) { // 处理 s 的逻辑 }
```

设集合为 s，**从大到小**枚举 s 的所有非空子集 sub：

```c++
for (int sub = s; sub; sub = (sub - 1) & s) { // 处理 sub 的逻辑 }
```

为什么要写成 `sub = (sub - 1) & s` 呢？
![[Pasted image 20230616114606.png]]















