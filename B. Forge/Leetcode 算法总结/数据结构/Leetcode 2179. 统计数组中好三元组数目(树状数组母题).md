给你两个下标从 **0** 开始且长度为 `n` 的整数数组 `nums1` 和 `nums2` ，两者都是 `[0, 1, ..., n - 1]` 的 **排列** 。

**好三元组** 指的是 `3` 个 **互不相同** 的值，且它们在数组 `nums1` 和 `nums2` 中出现顺序保持一致。换句话说，如果我们将 `pos1v` 记为值 `v` 在 `nums1` 中出现的位置，`pos2v` 为值 `v` 在 `nums2` 中的位置，那么一个好三元组定义为 `0 <= x, y, z <= n- 1` ，且 `pos1x < pos1y < pos1z` 和 `pos2x < pos2y < pos2z` 都成立的 `(x, y, z)` 。

请你返回好三元组的 **总数目** 。

**示例 1：**

```
输入：nums1 = [2,0,1,3], nums2 = [0,1,2,3]
输出：1
解释：
总共有 4 个三元组 (x,y,z) 满足 pos1x < pos1y < pos1z ，分别是 (2,0,1) ，(2,0,3) ，(2,1,3) 和 (0,1,3) 。
这些三元组中，只有 (0,1,3) 满足 pos2x < pos2y < pos2z 。所以只有 1 个好三元组。
```

**提示 1**
nums1​ 要是变成 [0,1,2,…,n−1] 就会简单不少。
**提示 2**
枚举 y。

#### 前置知识：置换

**置换**是一个排列到另一个排列的双射。

以示例 2 为例，定义下列置换 $P(x)$：
$$
\begin{pmatrix}
x & 0 & 1 & 2 & 3 & 4 \\
P(x) & 1 & 2 & 4 & 3 & 0
\end{pmatrix}
$$

我们可以把[4,0,1,3,2] 中的每个元素 $x$ 替换为 $P(x)$ 这样可以得到一个新的排列[0,1,2,3,4]同理可以将[4,1,0,2,3] 通过置换得到新的排列[0,2,1,4,3].
将 $nums1$ 置换成 [0,1,2,…,n−1]，设这一置换为 $P(x)$，将 $P(x)$ 也应用到 $nums2$ 上。对于$nums1​$ 和 $nums2$​ 中的相同元素，在置换后仍然是相同的，且元素的位置仍然是不变的，因此置换操作不会影响答案个数。

由于 $nums1$​ 置换成了[0,1,2,…,n−1]，因此置换后的好三元组 $(x,y,z)$需满足$x\leq y\leq z$ 。枚举置换后的 $nums2$​ 中的 y，问题就变成计算元素 y 的左侧有多少个比 y 小的数，以及右侧有多少个比 y 大的数。这可以用树状数组/线段树/名次树来完成（Python 可以直接用 `SortedList`），下面代码用的是树状数组。

有一道题也用到了这种置换思想：

- [1713. 得到子序列的最少操作次数](https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence/)

```C++
class Solution {
public:
    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size();
        vector<int> p(n);
        for(int i = 0; i < n; ++i) {
            p[nums1[i]] = i;
        }
        long long res = 0;
        vector<int> tree(n + 1);
        for(int i = 1; i < n - 1; ++i) {
            for(int j = p[nums2[i - 1]] + 1; j <= n; j += (j & -j)) {
                ++tree[j];
            }
            int y = p[nums2[i]], less = 0;
            for(int j = y; j; j &= j - 1) {
                less += tree[j];
            }
            res += (long)less * (n - 1 - y - ( ));
        }
        return res;
    }
};
```


# 树状数组

[树状数组](https://so.csdn.net/so/search?q=树状数组&spm=1001.2101.3001.7020)确实是个好东西啊，以前搞比赛的时候了解过它，会套用模版，但确没有深入理解这个东西，先学会用轮子，然后再学造轮子嘛，这段时间再回头研究了一下，发现二进制在算法中真的是的好东西，它可以使算法的时间复杂度降到`n`的二进制表示中的`1`相关，大家都知道，求一个二进制中的`1`的个数，这个[时间复杂度](https://so.csdn.net/so/search?q=时间复杂度&spm=1001.2101.3001.7020)为$\mathcal{O}(logn)$ 。

有时候觉得树状数组难以理解，我觉得根本原因是：你还在用十进制的视角来看待树状数组，下面的讲解我会时刻提醒你转换到二进制的视角，而且我也不会先给你上图，因为你的视角在二进制，你就会发现树状数组就是一个普通的东西，不需要图你就能理解。



## 树状数组的问题模型

首先我们搞明白树状数组是用来干嘛的，现在有一个这样的问题：有一个数组`a`，下标从`0`到`n-1`，现在给你`w`次修改，`q`次查询，修改的话是修改数组中某一个元素的值；查询的话是查询数组中任意一个区间的和，`w + q < 500000`。

这个问题很常见，首先分析下朴素做法的时间复杂度，修改是$\mathcal{O}(n)$的时间复杂度，而查询的话是$\mathcal{O}(n)$的复杂度，总体时间复杂度为$\mathcal{O}(qlogn)$ ；可能你会想到前缀和来优化这个查询，我们也来分析下，查询的话是$\mathcal{O}(1)$的复杂度，而修改的时候修改一个点，那么在之后的所有前缀和都要更新，所以修改的时间复杂度是$\mathcal{O}(n)$ ，总体时间复杂度还是$\mathcal{O}(qn)$ 。

可以发现，两种做法中，要么查询是$\mathcal{O}(1)$ ，修改是$\mathcal{O}(n)$ ；要么修改是$\mathcal{O}(1)$ ，查询是$\mathcal{O}(n)$。那么就有没有一种做法可以综合一下这两种朴素做法，然后整体时间复杂度可以降一个数量级呢？有的，对，就是树状数组。



## `lowbit`函数

这里我们先不管树状数组这种数据结构到底是什么，先来了解下`lowbit`这个函数，你也先不要问这个函数到底在树状数组中有什么用；

顾名思义，`lowbit`这个函数的功能就是求某一个数的二进制表示中最低的一位`1`，举个例子，`x = 6`，它的二进制为`110`，那么`lowbit(x)`就返回`2`，因为最后一位`1`表示`2`。

那么怎么求`lowbit`呢？

- 还记得[ 剑指Offer66题之每日6题 - 第二天](http://blog.csdn.net/flushhip/article/details/78934834)中的第五题中讲过的如何消掉最后一位`1`吗？我们就是先消掉最后一位`1`，然后再用原数减去消掉最后一位`1`后的数，答案就是`lowbit(x)`的结果；

  > x & = (x - 1)

- 第二种方法就是计算机组成原理课上老师教过我们求负数的补码的简便方法：**把这个数的二进制写出来，然后从右向左找到第一个`1`(这个`1`就是我们要求的结果，但是现在表示不出来，后来的操作就是让这个`1`能表示出来)，这个`1`不要动和这个`1`右边的二进制不变，左边的二进制依次取反，这样就求出的一个数的补码**，说这个方法主要是让我们理解一个负数的补码在二进制上的特征，然后我们把这个负数对应的正数与该负数与运算一下，由于这个`1`的左边的二进制与正数的原码对应的部分是相反的，所以相与一定都为0,；由于这个`1`和这个`1`右边的二进制都是不变的，因此，相与后还是原来的样子，故，这样搞出来的结果就是`lowbit(x)`的结果。

两种方法对应的代码依次如下：

```c++
int lowbit(x) 
{	
    return x - (x & (x - 1));
}
```

```c++
int lowbit(x) 
{	
    return x & -x;
}
```

## 树状数组的思想

在树状数组的问题模型中已经有所提及了，就是那两种不同做法的一个综合；

先定义一些东西：`arr`是原数组，`c`是新开的一个数组，这个数组代表后缀和(问题模型中是用的前缀和，这里要用后缀和，具体原因马上就知道了)；

二进制的视角：一个数`n`，假设`n = 6`，它的二进制为`110`，我们把它表示成累加的形式`110 = 100 + 10`，这样是可以的，那么我们要求前`6(110)`项的和是不是可以这样求：
$$
\sum_{i = 1}^{6} = (arr_1 + arr_2 + arr_3 + arr_4) + (arr_5 + arr_6)
$$
注意括号中的元素个数，是不是`4(100)`个加`2(10)`个，和`110 = 100 + 10`是不是很像，不知你们发现了吗，`10`就是`lowbit(110)`的结果，`100`是`lowbit(100)`的结果。求和的时候我们总是把$\sum_{i = 1}^{6}$拆分成这样的几段区间和来计算，而如何去确定这些区间的起点和长度呢？就是根据`n`的二进制来的(不懂的可以再看下上面举的例子)，二进制怎么拆的，你就怎么拆分，而拆分二进制就要用到上面说的`lowbit`函数了。这里也可以顺理成章得给出`c`数组的表示了。

这里也可以顺理成章得给出`c`数组的表示了，`c[i]`表示从第`i`个元素向前数`lowbit(i)`个元素，这一段的和，这就是上面说的区间和，只不过这个区间是靠右端点的；你可能又会想，不是说区间是靠右端点的吗，是后缀和啊，那中间的这些区间怎么定义？其实递归定义就好了，比如说:
$$
\sum_{i = 1}^{6} = (arr_1 + arr_2 + arr_3 + arr_4) + (arr_5 + arr_6)
$$
你把`c[6]`去掉，不就是$\sum_{i = 1}^{4} = arr_1 + arr_2 + arr_3 + arr_4$这个区间不就靠右端点了吗，$\sum_{i = 1}^4 = c[4] = c[6 - lowbit(6)]$

**其实你把所有的数字都看成二进制，很好理解的。**

## 树状数组的实现

设计一种数据结构，需要的操作无非就是”增删改查“，这里只讨论查询和修改操作具体是怎么实现的；

### 查询

这里说的查询是查询任一区间的和，由于区间和具有可加减性，故转化为求前缀和；

查询前缀和刚刚在树状数组的思想中已经说过了，就是把大区间分成几段长度不等的小区间，然后求和。区间的个数为​，所以查询的时间复杂度为​。

### 修改

修改某一位置上的元素的时间复杂度为 ，但是要更新`c`数组，不然查询的时间复杂度就会变高。更新的方法就要提一下树状数组的性质了和树状数组那张经典的图片了。

![[Pasted image 20230704220021.png]]

这张图片中已经把`c`数组的后缀和这个含义已经表达得很清楚了。这个时候你再把查询操作对应到这张图上，然后看着二进制来操作，是不是就可以很直白地理解上面所说的查询操作了！

我们从这张图中可以得到树状数组的如下性质：

- 后缀和的长度是2的幂；
    
- 上一层后缀和的长度是下一层后缀和长度的两倍；
    
- 下一层后缀和只要补上自己后缀和的长度就可以得到上面层的后缀和(图中的虚框框)，注意，是上面的后缀和，而不是上一层的后缀和，这个性质就是更新操作的依据；
    
-  最后一位`1`右边有多少个`0`(可以用​​​​$\log_2(lowbit(x))$表示)就表示这一层有多少个直系子层(子层的意思就是这一层的和包含下面某一层的和)。
    

我暂时就写这么多吧，这个时候我们再来说更新操作；

更新的时候只要更新修改这个点会影响到的那些后缀和(`c`数组)，假设现在修改`6(110)`这个点，依据树状数组的性质三，它影响的直系父层就是`c[6(110) + lowbit(6(110))] = c[8(1000)]`，但是它肯定不是只影响直系父层，上面所有包含这一层和的层都要更新，但是我们把这个更新传递给直系父层`c[8]`,`8`这个点的直系父层是`c[16]`，依次类推地更新就行了。
